// Generated by CoffeeScript 1.7.1
(function() {
  var FrameSplicer;

  FrameSplicer = (function() {
    function FrameSplicer(userId) {
      this.userId = userId;
      console.assert(this.userId);
    }

    FrameSplicer.prototype.makeIdsUniversal = function(frameData) {
      var hand, pointable, _i, _j, _len, _len1, _ref, _ref1, _results;
      frameData.id += '-' + this.userId;
      _ref = frameData.hands;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hand = _ref[_i];
        hand.userId = this.userId;
        hand.id += '-' + this.userId;
        console.assert(typeof hand.id === "string", "Invalid hand id: " + hand.id);
      }
      _ref1 = frameData.pointables;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        pointable = _ref1[_j];
        pointable.id += '-' + this.userId;
        _results.push(pointable.handId += '-' + this.userId);
      }
      return _results;
    };

    return FrameSplicer;

  })();

  Leap.plugin('networking', function(scope) {
    var frameSplicer;
    if (!scope.peer) {
      console.warn("No Peer supplied");
    }
    scope.connection = null;
    scope.sendFrames = false;
    frameSplicer = null;
    scope.peer.on('error', function(error) {
      console.log('peerjs error, not sending frames:', error, error.type);
      return scope.sendFrames = false;
    });
    scope.peer.on('connection', function(connection) {
      console.log("incoming " + connection.type + " connection from " + connection.peer);
      scope.connection = connection;
      return scope.connectionEstablished();
    });
    scope.connect = function(id) {
      scope.connection = scope.peer.connect(id);
      console.log("outgoing " + scope.connection.type + " connection to " + scope.connection.peer);
      return scope.connectionEstablished();
    };
    scope.connectionEstablished = function() {
      scope.sendFrames = true;
      return scope.connection.on('data', function(data) {
        return console.log('received:', data);
      });
    };
    scope.peer.on('open', function(id) {
      return frameSplicer = new FrameSplicer(id);
    });
    return {
      beforeFrameCreated: function(frameData) {
        if (!scope.sendFrames) {
          return;
        }
        console.assert(frameSplicer);
        frameSplicer.makeIdsUniversal(frameData);
        console.log('send frame', frameData.id);
        return scope.connection.send(frameData.id);
      },
      afterFrameCreated: function(frame, rawFrameData) {
        var hand, i, pointable, _i, _j, _len, _len1, _ref, _ref1, _results;
        _ref = frame.hands;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          hand = _ref[i];
          hand.id = rawFrameData.hands[i].id;
          hand.userId = rawFrameData.hands[i].userId;
        }
        _ref1 = frame.pointables;
        _results = [];
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          pointable = _ref1[i];
          _results.push(pointable.userId = rawFrameData.pointables[i].userId);
        }
        return _results;
      }
    };
  });

}).call(this);
